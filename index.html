<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>HOW Christmas Game — Auto Logo + Gesture Guide</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">

  <style>
    body { margin:0; overflow:hidden; background:#050505; font-family:'Cinzel',serif; user-select:none; }
    #canvas-container { position:absolute; inset:0; z-index:1; }

    #topbar{
      position:absolute; top:16px; left:16px; right:16px; z-index:15;
      display:flex; gap:10px; align-items:flex-start; flex-wrap:wrap;
      pointer-events:none;
    }
    #controls{
      pointer-events:auto;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(212,175,55,.35);
      border-radius:12px;
      padding:10px;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .btn{
      border:1px solid rgba(212,175,55,.75);
      color:#D4AF37;
      background:transparent;
      padding:8px 12px;
      border-radius:10px;
      font-family:'Cinzel',serif;
      font-size:12px;
      letter-spacing:.08em;
      text-transform:uppercase;
      cursor:pointer;
    }
    .btn:hover{ background:#D4AF37; color:#000; }

    #hud{
      pointer-events:none;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(212,175,55,.35);
      border-radius:12px;
      padding:10px 12px;
      color:#fff;
      font-size:12px;
      white-space:pre-wrap;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      max-width:min(640px, 92vw);
    }

    #mode{
      position:absolute; top:16px; right:16px; z-index:12;
      background:rgba(0,0,0,.35);
      border:1px solid rgba(212,175,55,.45);
      border-radius:999px;
      padding:8px 12px;
      color:#D4AF37;
      font-size:12px;
      letter-spacing:.14em;
      text-transform:uppercase;
      display:none;
      pointer-events:none;
    }

    #webcam-preview{
      position:absolute; bottom:16px; right:16px; width:160px; height:120px;
      border:2px solid #D4AF37; opacity:.6; z-index:20; transform:scaleX(-1); border-radius:10px;
    }

    #loading{
      position:absolute; inset:0; z-index:99; display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.92); color:#D4AF37; font-size:16px; text-align:center; padding:24px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      white-space:pre-wrap;
    }

    #story-overlay{
      position:absolute; inset:0; z-index:60;
      display:none; align-items:center; justify-content:center;
      background:rgba(0,0,0,0.78);
      pointer-events:none;
    }
    #story-card{
      width:min(78vw, 980px);
      height:min(78vh, 720px);
      border:1px solid rgba(212,175,55,0.75);
      border-radius:14px;
      background:rgba(10,10,10,0.85);
      box-shadow:0 0 40px rgba(212,175,55,0.15);
      display:flex; flex-direction:column;
      overflow:hidden;
    }
    #story-header{
      padding:14px 18px;
      border-bottom:1px solid rgba(212,175,55,0.25);
      color:#D4AF37;
      letter-spacing:0.08em;
      display:flex; justify-content:space-between; align-items:center; gap:12px;
    }
    #story-header span{
      letter-spacing:0; color:#fff; opacity:0.85; font-style:italic; font-size:14px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    #story-img-wrap{ flex:1; display:flex; align-items:center; justify-content:center; padding:16px; }
    #story-img{ max-width:100%; max-height:100%; object-fit:contain; border-radius:10px; }

    #gesture-help{
      position:absolute;
      left:16px;
      bottom:16px;
      z-index:25;
      max-width:min(420px, calc(100vw - 220px));
      background:rgba(0,0,0,.45);
      border:1px solid rgba(212,175,55,.35);
      border-radius:12px;
      padding:10px 12px;
      color:#fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size:12px;
      line-height:1.45;
      pointer-events:none;
      white-space:pre-wrap;
    }
    #gesture-help .title{
      color:#D4AF37;
      font-weight:700;
      letter-spacing:.08em;
      text-transform:uppercase;
      margin-bottom:6px;
      font-size:12px;
    }
    #gesture-help .row{ opacity:.92; }
    #gesture-help .key{ color:#D4AF37; font-weight:700; }
    #gesture-help .meta{ opacity:.85; margin-top:6px; }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
    }
  }
  </script>
</head>
<body>
  <div id="loading">Loading...</div>

  <div id="topbar">
    <div id="controls">
      <button class="btn" id="btn-next-story">Next Story (Debug)</button>
    </div>
    <div id="hud">Boot...</div>
  </div>

  <div id="mode">STORY MODE</div>

  <div id="story-overlay">
    <div id="story-card">
      <div id="story-header">
        <div>STORY VIEW</div>
        <span>Pinch: next · OK-Sign: exit</span>
      </div>
      <div id="story-img-wrap">
        <img id="story-img" alt="Story" />
      </div>
    </div>
  </div>

  <div id="gesture-help">
    <div class="title">Gesture Guide</div>
    <div class="row"><span class="key">Open Hand</span> → Scatter & Enter Story Mode</div>
    <div class="row"><span class="key">Fist</span> → Tree</div>
    <div class="row"><span class="key">Thumbs Up</span> → Heart</div>
    <div class="row"><span class="key">V Sign</span> → Logo</div>
    <div class="row"><span class="key">Story Mode</span> → Pinch = Random Story Image · OK-Sign = Exit Zoom</div>
    <div class="meta" id="gesture-meta">Status: —</div>
  </div>

  <video id="webcam-preview" autoplay playsinline muted></video>
  <div id="canvas-container"></div>

  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // --------- CONFIG (固定从 assets 读) ----------
    const CONFIG = {
      particleCount: 4000,
      particleSize: 1,
      snowCount: 800,

      bloom: { threshold: 0.1, strength: 1.0, radius: 0.5 },

      gestureHistory: 10,
      minVotesToSwitch: 7,
      switchCooldownMs: 550,
      
      
      pinchThreshold: 0.23,
      pinchRelease: 0.30,
      pinchCooldownMs: 550,

      okThreshold: 0.23,
      okHoldMs: 220,

      minHandScaleForPinch: 0.085,
      framesToArmPinch: 6,

      // 两张 tip（你也可以改成 manifest 方式，但这里先写死更稳）
      tipA: './assets/tip/tip1.png',
      tipB: './assets/tip/tip2.png',

      // story 写死（你可自行加）
      story: [
        './assets/story/001.jpg',
        './assets/story/002.jpg',
        './assets/story/003.jpg',
      ],

      // brand logo 固定路径（按钮只是 reload）
      brandLogo: './assets/logo/brand_logo.png',

      // logo sampling: 支持 PNG 透明 / JPG 无透明（亮度阈值）
      logoSampleStep: 2,
      alphaThreshold: 40,      // PNG 有透明时用
      lumaThreshold: 205,      // JPG/无透明时用（越小越“吃底色”）
      logoScale: 0.085,
      logoYOffset: 2.0
    };

    const hud = document.getElementById('hud');
    const modeBadge = document.getElementById('mode');
    const loading = document.getElementById('loading');
    const storyOverlay = document.getElementById('story-overlay');
    const storyImg = document.getElementById('story-img');
    const gestureMeta = document.getElementById('gesture-meta');

    document.getElementById('btn-next-story').addEventListener('click', () => showRandomStoryImage());
    

    let scene, camera, renderer, composer;
    let handLandmarker;
    let snowSystem, starMesh;

    let targetShape = 'tree';
    const masterPositions = new Float32Array(CONFIG.particleCount * 3);
    const masterColors = new Float32Array(CONFIG.particleCount * 3);

    let treeTargets, heartTargets, logoTargets, explodeTargets;

    let storyMode = false;
    const storyImages = CONFIG.story.slice();
    let lastStoryIndex = -1;

    let wasPinched = false;
    let lastPinchFire = 0;
    let okCandidateStart = 0;
    let okActive = false;

    const gestureQueue = [];
    let currentStableGesture = null;
    let lastSwitchTime = 0;

    let noHandFrames = 0;
    let handPresentFrames = 0;
    let pinchArmed = false;

    let particleClouds = [];
    let particleTextures = [];

    let logoStatus = 'INIT';
    let logoResolvedUrl = '';

    const clock = new THREE.Clock();

    function setHUD(extra='') {
      hud.textContent =
        `Page: ${location.href}\n` +
        `BrandLogo: ${logoResolvedUrl || '(resolving...)'}\n` +
        `LogoStatus: ${logoStatus}\n` +
        `LogoTargets: ${logoTargets ? 'READY' : '—'}\n` +
        `Story: ${storyImages.length}\n` +
        `Gesture: ${currentStableGesture || '—'} | StoryMode=${storyMode} | Zoom=${isZoomVisible()}\n` +
        (extra ? `\n${extra}\n` : '');

      gestureMeta.textContent =
        `Status: Gesture=${currentStableGesture || '—'} | StoryMode=${storyMode} | Zoom=${isZoomVisible()} | HandPresent=${handPresentFrames>0}`;
    }

    async function init() {
      try {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 35);

        renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloom.threshold;
        bloomPass.strength = CONFIG.bloom.strength;
        bloomPass.radius = CONFIG.bloom.radius;

        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        generateTreeData();
        generateHeartData();
        generateExplodeData();

        for (let i = 0; i < CONFIG.particleCount * 3; i++) masterPositions[i] = explodeTargets[i];
        for (let i = 0; i < CONFIG.particleCount; i++) {
          const i3 = i * 3;
          masterColors[i3] = 1; masterColors[i3 + 1] = 1; masterColors[i3 + 2] = 1;
        }

        loading.textContent = "Loading tip textures...";
        particleTextures = [
          await loadTextureFromUrl(CONFIG.tipA),
          await loadTextureFromUrl(CONFIG.tipB),
        ];

        loading.textContent = "Loading brand logo from folder...";
        await loadBrandLogoFromFolder(true);

        rebuildParticleCloudsBalanced(particleTextures);
        createSnow();
        createStar();

        loading.textContent = "Loading hand tracking...";
        await initMediaPipe();

        loading.remove();
        setHUD();
        clock.start();
        animate();
        window.addEventListener('resize', onWindowResize);

      } catch (e) {
        console.error(e);
        loading.style.display = 'flex';
        loading.textContent =
          "Failed to start.\n\n" +
          String(e) + "\n\n" +
          "Check:\n" +
          "- assets/logo/brand_logo.png exists and filename case matches.\n" +
          "- Tip files exist.\n";
      }
    }

    // --------- texture load ----------
    function configureTexture(tex) {
      tex.wrapS = THREE.ClampToEdgeWrapping;
      tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.generateMipmaps = false;
      tex.anisotropy = 1;
      tex.needsUpdate = true;
    }

    function resolveUrl(rel) {
      return new URL(rel, window.location.href).href;
    }

    function cacheBust(url) {
      const u = new URL(url);
      u.searchParams.set('v', String(Date.now()));
      return u.href;
    }

    function loadTextureFromUrl(relOrAbs) {
      const abs = resolveUrl(relOrAbs);
      return new Promise((resolve, reject) => {
        const img = new Image();
        // GitHub Pages 上通常没问题；如果你换域名，anonymous 也安全
        img.crossOrigin = "anonymous";
        img.decoding = "async";
        img.onload = () => {
          const tex = new THREE.Texture(img);
          tex.colorSpace = THREE.SRGBColorSpace;
          configureTexture(tex);
          resolve(tex);
        };
        img.onerror = () => reject(new Error("Texture load failed:\n" + abs));
        img.src = abs;
      });
    }

    // --------- BRAND LOGO from folder ----------
    async function loadBrandLogoFromFolder(forceBust=false) {
      try {
        logoStatus = 'LOADING';
        const abs = resolveUrl(CONFIG.brandLogo);
        logoResolvedUrl = forceBust ? cacheBust(abs) : abs;
        setHUD('Loading logo...');

        const tex = await new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.decoding = "async";
          img.onload = () => {
            const t = new THREE.Texture(img);
            t.colorSpace = THREE.SRGBColorSpace;
            configureTexture(t);
            resolve(t);
          };
          img.onerror = () => reject(new Error("Brand logo load failed:\n" + logoResolvedUrl));
          img.src = logoResolvedUrl;
        });

        await generateLogoFromTextureSmart(tex);
        logoStatus = 'READY';
        setHUD('Logo ready (V Sign to view).');
      } catch (e) {
        console.warn(e);
        logoStatus = 'FALLBACK';
        generateLogoFromTextFallback("LOGO");
        setHUD('Logo fallback used. Check path/case or logo format.');
      }
    }

    // NEW: 支持透明 PNG / 非透明 JPG（用亮度阈值）
    async function generateLogoFromTextureSmart(tex) {
      const img = tex.image;
      if (!img || !img.width || !img.height) throw new Error('Logo image not available');

      const canvas = document.createElement('canvas');
      const maxW = 640;
      const scale = Math.min(1, maxW / img.width);
      canvas.width = Math.max(1, Math.floor(img.width * scale));
      canvas.height = Math.max(1, Math.floor(img.height * scale));

      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      const { data, width, height } = ctx.getImageData(0, 0, canvas.width, canvas.height);

      let hasMeaningfulAlpha = false;
      // quick scan: if any alpha < 250, treat as transparent logo
      for (let i = 3; i < data.length; i += 4 * 60) {
        if (data[i] < 250) { hasMeaningfulAlpha = true; break; }
      }

      const pts = [];
      const step = CONFIG.logoSampleStep;
      const aTh = CONFIG.alphaThreshold;
      const lTh = CONFIG.lumaThreshold;

      for (let y = 0; y < height; y += step) {
        for (let x = 0; x < width; x += step) {
          const k = (y * width + x) * 4;
          const r = data[k], g = data[k+1], b = data[k+2], a = data[k+3];

          if (hasMeaningfulAlpha) {
            if (a > aTh) pts.push({x,y});
          } else {
            // use brightness threshold (assume logo is darker on light bg OR vice versa)
            const luma = 0.2126*r + 0.7152*g + 0.0722*b;
            // pick "non-white" pixels by default
            if (luma < lTh) pts.push({x,y});
          }
        }
      }

      if (pts.length < 120) {
        // fallback: try inverse (logo white on dark bg)
        if (!hasMeaningfulAlpha) {
          pts.length = 0;
          for (let y = 0; y < height; y += step) {
            for (let x = 0; x < width; x += step) {
              const k = (y * width + x) * 4;
              const r = data[k], g = data[k+1], b = data[k+2];
              const luma = 0.2126*r + 0.7152*g + 0.0722*b;
              if (luma > 255 - lTh) pts.push({x,y});
            }
          }
        }
      }

      if (pts.length < 120) throw new Error(`Logo sampling found too few points (${pts.length}).`);

      // shuffle
      for (let i = pts.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        const t = pts[i]; pts[i] = pts[j]; pts[j] = t;
      }

      logoTargets = new Float32Array(CONFIG.particleCount * 3);
      const cx = width/2, cy = height/2;
      const s = CONFIG.logoScale, yOff = CONFIG.logoYOffset;

      for (let i = 0; i < CONFIG.particleCount; i++) {
        const p = pts[i % pts.length];
        logoTargets[i*3] = (p.x - cx) * s;
        logoTargets[i*3 + 1] = -(p.y - cy) * s + yOff;
        logoTargets[i*3 + 2] = 0;
      }
    }

    function generateLogoFromTextFallback(text) {
      const canvas = document.createElement('canvas');
      canvas.width = 420; canvas.height = 160;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 90px "Cinzel"';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);

      const { data, width, height } = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const pts = [];
      for (let y = 0; y < height; y += 2) {
        for (let x = 0; x < width; x += 2) {
          const r = data[(y * width + x) * 4];
          if (r > 128) pts.push({ x, y });
        }
      }

      logoTargets = new Float32Array(CONFIG.particleCount * 3);
      const cx = width/2, cy = height/2;
      const s = 0.08, yOff = 2.0;

      for (let i = 0; i < CONFIG.particleCount; i++) {
        const p = pts[i % pts.length] || { x: cx, y: cy };
        logoTargets[i*3] = (p.x - cx) * s;
        logoTargets[i*3 + 1] = -(p.y - cy) * s + yOff;
        logoTargets[i*3 + 2] = 0;
      }
    }

    // --------- particles 50/50 ----------
    function rebuildParticleCloudsBalanced(textures) {
      for (const c of particleClouds) {
        scene.remove(c.points);
        c.points.geometry.dispose();
        c.points.material.dispose();
      }
      particleClouds = [];

      const all = new Uint32Array(CONFIG.particleCount);
      for (let i = 0; i < CONFIG.particleCount; i++) all[i] = i;
      for (let i = all.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        const tmp = all[i]; all[i] = all[j]; all[j] = tmp;
      }

      const half = Math.floor(CONFIG.particleCount / 2);
      const sizes = [CONFIG.particleCount - half, half];

      let cursor = 0;
      const groups = sizes.map(sz => {
        const sub = new Uint32Array(sz);
        for (let i = 0; i < sz; i++) sub[i] = all[cursor++];
        return sub;
      });

      for (let g = 0; g < 2; g++) {
        const idxArr = groups[g];
        const count = idxArr.length;

        const positions = new Float32Array(count * 3);
        const colors = new Float32Array(count * 3);

        for (let j = 0; j < count; j++) {
          const p = idxArr[j];
          const p3 = p * 3;
          const j3 = j * 3;
          positions[j3] = masterPositions[p3];
          positions[j3 + 1] = masterPositions[p3 + 1];
          positions[j3 + 2] = masterPositions[p3 + 2];
          colors[j3] = masterColors[p3];
          colors[j3 + 1] = masterColors[p3 + 1];
          colors[j3 + 2] = masterColors[p3 + 2];
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
          size: CONFIG.particleSize,
          vertexColors: true,
          map: textures[g],
          transparent: true,
          depthWrite: false,
          blending: THREE.NormalBlending,
          alphaTest: 0.01
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);
        particleClouds.push({ points, indices: idxArr, count });
      }
    }

    // --------- shapes ----------
    function generateExplodeData() {
      explodeTargets = new Float32Array(CONFIG.particleCount * 3);
      for (let i = 0; i < CONFIG.particleCount; i++) {
        const r = 10 + Math.random() * 30;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        explodeTargets[i * 3] = r * Math.sin(phi) * Math.cos(theta);
        explodeTargets[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
        explodeTargets[i * 3 + 2] = r * Math.cos(phi);
      }
    }

    function generateTreeData() {
  treeTargets = new Float32Array(CONFIG.particleCount * 3);
  
  // 定义颜色常量
  const colors = {
    forest: new THREE.Color(0x0B3D19), // 深绿
    emerald: new THREE.Color(0x1B5E20), // 翠绿
    gold: new THREE.Color(0xFFD700),   // 金色
    ruby: new THREE.Color(0xD00000),   // 红宝石
    trunk: new THREE.Color(0x3E2723)   // 深褐
  };

  for (let i = 0; i < CONFIG.particleCount; i++) {
    const i3 = i * 3;
    
    // 1. 树干部分 (占10%的粒子)
    if (i < CONFIG.particleCount * 0.1) {
      const r = Math.random() * 0.5;
      const theta = Math.random() * Math.PI * 2;
      const y = (Math.random() * 4) - 7; // 树干位置
      
      treeTargets[i3] = r * Math.cos(theta);
      treeTargets[i3 + 1] = y;
      treeTargets[i3 + 2] = r * Math.sin(theta);

      masterColors[i3] = colors.trunk.r;
      masterColors[i3 + 1] = colors.trunk.g;
      masterColors[i3 + 2] = colors.trunk.b;
    } 
    // 2. 树叶与装饰 (占90%)
    else {
      // 使用三次方曲线让顶部更尖，底部更宽
      const hNorm = Math.pow(Math.random(), 1.2); 
      const height = 18; 
      const y = (hNorm * height) - 4;

      // 增加“层叠感”：通过正弦函数模拟树的分层
      const layerEffect = 0.2 * Math.sin(hNorm * 15);
      const radiusAtHeight = (1 - hNorm) * 7 * (1 + layerEffect);
      
      const r = radiusAtHeight * Math.sqrt(Math.random());
      const theta = Math.random() * Math.PI * 2;

      treeTargets[i3] = r * Math.cos(theta);
      treeTargets[i3 + 1] = y;
      treeTargets[i3 + 2] = r * Math.sin(theta);

      // 色彩逻辑
      const colorRand = Math.random();
      if (colorRand > 0.96) {
        // 金色装饰灯 (自带发光效果，受Bloom影响)
        masterColors[i3] = colors.gold.r * 2; 
        masterColors[i3 + 1] = colors.gold.g * 2;
        masterColors[i3 + 2] = colors.gold.b * 0.5;
      } else if (colorRand > 0.92) {
        // 红色装饰球
        masterColors[i3] = colors.ruby.r;
        masterColors[i3 + 1] = colors.ruby.g;
        masterColors[i3 + 2] = colors.ruby.b;
      } else {
        // 渐变绿色树叶
        const mixColor = colors.forest.clone().lerp(colors.emerald, Math.random());
        masterColors[i3] = mixColor.r;
        masterColors[i3 + 1] = mixColor.g;
        masterColors[i3 + 2] = mixColor.b;
      }
    }
  }
}
    function generateHeartData() {
      heartTargets = new Float32Array(CONFIG.particleCount * 3);
      const cRed = new THREE.Color(0xD00000);
      for (let i = 0; i < CONFIG.particleCount; i++) {
        const t = Math.random() * Math.PI * 2;
        const r = Math.random();
        const scale = 0.5;

        let x = 16 * Math.pow(Math.sin(t), 3);
        let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
        x *= scale * r;
        y *= scale * r;

        heartTargets[i * 3] = x;
        heartTargets[i * 3 + 1] = y + 2;
        heartTargets[i * 3 + 2] = (Math.random() - 0.5) * 4 * r;

        masterColors[i * 3] = cRed.r; masterColors[i * 3 + 1] = cRed.g; masterColors[i * 3 + 2] = cRed.b;
      }
    }

    // --------- snow/star ----------
    let snowPositions, snowVelocities;
    function createSnow() {
      const geo = new THREE.BufferGeometry();
      snowPositions = new Float32Array(CONFIG.snowCount * 3);
      snowVelocities = new Float32Array(CONFIG.snowCount);

      for (let i = 0; i < CONFIG.snowCount; i++) {
        snowPositions[i * 3] = (Math.random() - 0.5) * 60;
        snowPositions[i * 3 + 1] = Math.random() * 40;
        snowPositions[i * 3 + 2] = (Math.random() - 0.5) * 60;
        snowVelocities[i] = 0.8 + Math.random() * 1.8;
      }

      geo.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
      const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true, opacity: 0.6 });
      snowSystem = new THREE.Points(geo, mat);
      scene.add(snowSystem);
    }

    function createStar() {
      const geo = new THREE.OctahedronGeometry(0.8);
      const mat = new THREE.MeshBasicMaterial({ color: 0xD4AF37 });
      starMesh = new THREE.Mesh(geo, mat);
      starMesh.position.y = 9;
      scene.add(starMesh);
    }

    // --------- mediapipe ----------
    async function initMediaPipe() {
      const vision = await FilesetResolver.forVisionTasks(
        'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm'
      );
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath:
            'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task'
        },
        numHands: 1,
        runningMode: 'VIDEO',
        minHandDetectionConfidence: 0.65,
        minHandPresenceConfidence: 0.65,
        minTrackingConfidence: 0.65
      });
      await startWebcam();
    }

    async function startWebcam() {
      const video = document.getElementById('webcam-preview');
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user', width: 640, height: 480 }
      });
      video.srcObject = stream;
      await new Promise(res => video.addEventListener('loadeddata', res, { once: true }));
      processVideo();
    }

    // --------- story ----------
    function isZoomVisible() { return storyOverlay.style.display === 'flex'; }
    function exitZoomOnly() { storyOverlay.style.display = 'none'; }

    function showRandomStoryImage() {
      if (!storyImages.length) return;
      let idx = Math.floor(Math.random() * storyImages.length);
      if (storyImages.length > 1 && idx === lastStoryIndex) idx = (idx + 1) % storyImages.length;
      lastStoryIndex = idx;
      storyImg.src = resolveUrl(storyImages[idx]);
      storyOverlay.style.display = 'flex';
    }

    function setStoryMode(on) {
      storyMode = on;
      modeBadge.style.display = storyMode ? 'block' : 'none';
      if (!storyMode) storyOverlay.style.display = 'none';
      handPresentFrames = 0;
      pinchArmed = false;
      wasPinched = false;
    }

    // --------- gesture loop ----------
    let lastVideoTime = -1;
    function processVideo() {
      const video = document.getElementById('webcam-preview');

      if (video.readyState >= 2 && handLandmarker) {
        if (video.currentTime !== lastVideoTime) {
          const results = handLandmarker.detectForVideo(video, performance.now());

          if (results.landmarks && results.landmarks.length > 0) {
            noHandFrames = 0;
            handPresentFrames++;
            if (handPresentFrames >= CONFIG.framesToArmPinch) pinchArmed = true;

            const lm = results.landmarks[0];

            const okNow = detectOKSignRaw(lm);
            updateOkHold(okNow);

            detectGestureStable(lm);

            if (!(isZoomVisible() && okActive)) handlePinchEvent(lm);
          } else {
            noHandFrames++;
            handPresentFrames = 0;
            pinchArmed = false;
            wasPinched = false;
            okCandidateStart = 0;
            okActive = false;

            if (noHandFrames > 20) {
              gestureQueue.length = 0;
              currentStableGesture = null;
            }
          }

          lastVideoTime = video.currentTime;
          setHUD();
        }
      }
      requestAnimationFrame(processVideo);
    }


    function updateOkHold(okNow) {
      const now = performance.now();
      if (isZoomVisible()) {
        if (okNow) {
          if (okCandidateStart === 0) okCandidateStart = now;
          if (!okActive && (now - okCandidateStart) >= CONFIG.okHoldMs) {
            okActive = true;
            exitZoomOnly();
          }
        } else {
          okCandidateStart = 0;
          okActive = false;
        }
      } else {
        okCandidateStart = 0;
        okActive = false;
      }
    }

    function detectOKSignRaw(lm) {
      const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
      const wrist = lm[0];
      const handScale = Math.max(0.001, dist(wrist, lm[9]));
      const pinchNorm = dist(lm[4], lm[8]) / handScale;
      const thumbIndexClose = pinchNorm < CONFIG.okThreshold;

      const fingerExtended = (tipIdx, pipIdx, mcpIdx) => {
        const tip = lm[tipIdx], pip = lm[pipIdx], mcp = lm[mcpIdx];
        const margin = 0.25 * handScale;
        return (pip.y - tip.y) > margin && (mcp.y - tip.y) > margin;
      };
      return thumbIndexClose && fingerExtended(12, 10, 9) && fingerExtended(16, 14, 13) && fingerExtended(20, 18, 17);
    }


function handlePinchEvent(lm) {
      if (!storyMode || !pinchArmed) return;

      const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
      const wrist = lm[0];
      const handScale = Math.max(0.001, dist(wrist, lm[9]));
      if (handScale < CONFIG.minHandScaleForPinch) { wasPinched = false; return; }

      const pinchNorm = dist(lm[4], lm[8]) / handScale;
      const isPinched = pinchNorm < CONFIG.pinchThreshold;
      const isReleased = pinchNorm > CONFIG.pinchRelease;
      const now = performance.now();

      if (!wasPinched && isPinched) {
        if ((now - lastPinchFire) > CONFIG.pinchCooldownMs) {
          showRandomStoryImage();
          lastPinchFire = now;
        }
        wasPinched = true;
      }
      if (wasPinched && isReleased) wasPinched = false;
    }

// 修改 detectGestureStable 函数，同时检测 "open" 和 "pinch"
function detectGestureStable(lm) {
      const raw = detectGestureRaw(lm);
      if (raw) {
        gestureQueue.push(raw);
        if (gestureQueue.length > CONFIG.gestureHistory) gestureQueue.shift();
      } else {
        return currentStableGesture;
      }

      const counts = {};
      for (const g of gestureQueue) counts[g] = (counts[g] || 0) + 1;

      let best = null, bestCount = 0;
      for (const k in counts) {
        if (counts[k] > bestCount) { best = k; bestCount = counts[k]; }
      }

      const now = performance.now();
      const canSwitch = (now - lastSwitchTime) > CONFIG.switchCooldownMs;

      if (best && bestCount >= CONFIG.minVotesToSwitch && best !== currentStableGesture && canSwitch) {
        currentStableGesture = best;
        lastSwitchTime = now;

        if (best === 'fist') { targetShape = 'tree'; setStoryMode(false); }
        else if (best === 'open') { targetShape = 'explode'; setStoryMode(true); }
        else if (best === 'thumbsup') { targetShape = 'heart'; setStoryMode(false); }
        else if (best === 'vsign') { targetShape = 'logo'; setStoryMode(false); }
      }
      return currentStableGesture;
    }




    function detectGestureRaw(lm) {
      const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
      const wrist = lm[0];
      const handScale = Math.max(0.001, dist(wrist, lm[9]));

      const palmCenter = {
        x: (lm[0].x + lm[5].x + lm[9].x + lm[13].x + lm[17].x) / 5,
        y: (lm[0].y + lm[5].y + lm[9].y + lm[13].y + lm[17].y) / 5
      };
      const tipNearPalm = (tipIdx) => dist(lm[tipIdx], palmCenter) < (0.55 * handScale);

      const fingerExtended = (tipIdx, pipIdx, mcpIdx) => {
        const tip = lm[tipIdx], pip = lm[pipIdx], mcp = lm[mcpIdx];
        const margin = 0.25 * handScale;
        return (pip.y - tip.y) > margin && (mcp.y - tip.y) > margin;
      };

      const indexExt  = fingerExtended(8, 6, 5);
      const middleExt = fingerExtended(12, 10, 9);
      const ringExt   = fingerExtended(16, 14, 13);
      const pinkyExt  = fingerExtended(20, 18, 17);

      const thumbUp = (() => {
        const margin = 0.18 * handScale;
        const t4 = lm[4], t3 = lm[3], t2 = lm[2], t1 = lm[1];
        const thumbExtendedUp =
          (t3.y - t4.y) > margin &&
          (t2.y - t3.y) > margin * 0.6 &&
          (t1.y - t2.y) > margin * 0.4;

        const othersFolded =
          (!indexExt && !middleExt && !ringExt && !pinkyExt) &&
          tipNearPalm(8) && tipNearPalm(12) && tipNearPalm(16) && tipNearPalm(20);

        const thumbAwayFromPalm = dist(lm[4], palmCenter) > (0.75 * handScale);
        const thumbAboveWrist = (wrist.y - lm[4].y) > (0.12 * handScale);

        return thumbExtendedUp && othersFolded && thumbAwayFromPalm && thumbAboveWrist;
      })();

      if (thumbUp) return 'thumbsup';
      if (indexExt && middleExt && !ringExt && !pinkyExt) return 'vsign';
      if (indexExt && middleExt && ringExt && pinkyExt) return 'open';
      if (!indexExt && !middleExt && !ringExt && !pinkyExt &&
          tipNearPalm(8) && tipNearPalm(12) && tipNearPalm(16) && tipNearPalm(20)) return 'fist';
      return null;
    }

    // --------- render loop ----------
    function animate() {
      requestAnimationFrame(animate);

      const dt = Math.min(0.05, clock.getDelta());
      const lerp = 0.05;

      let source;
      if (targetShape === 'tree') source = treeTargets;
      else if (targetShape === 'heart') source = heartTargets;
      else if (targetShape === 'logo' && logoTargets) source = logoTargets;
      else source = explodeTargets;

      const useVertexColors = (targetShape === 'tree' || targetShape === 'heart' || (targetShape === 'logo' && !!logoTargets));

      for (let i = 0; i < CONFIG.particleCount; i++) {
        const i3 = i * 3;
        masterPositions[i3]     += (source[i3]     - masterPositions[i3])     * lerp;
        masterPositions[i3 + 1] += (source[i3 + 1] - masterPositions[i3 + 1]) * lerp;
        masterPositions[i3 + 2] += (source[i3 + 2] - masterPositions[i3 + 2]) * lerp;

        if (!useVertexColors) {
          masterColors[i3]     += (1 - masterColors[i3]) * 0.05;
          masterColors[i3 + 1] += (1 - masterColors[i3 + 1]) * 0.05;
          masterColors[i3 + 2] += (1 - masterColors[i3 + 2]) * 0.05;
        }
      }

      for (const cloud of particleClouds) {
        const posArr = cloud.points.geometry.attributes.position.array;
        const colArr = cloud.points.geometry.attributes.color.array;
        const idxArr = cloud.indices;

        for (let j = 0; j < idxArr.length; j++) {
          const p = idxArr[j];
          const p3 = p * 3;
          const j3 = j * 3;
          posArr[j3]     = masterPositions[p3];
          posArr[j3 + 1] = masterPositions[p3 + 1];
          posArr[j3 + 2] = masterPositions[p3 + 2];
          colArr[j3]     = masterColors[p3];
          colArr[j3 + 1] = masterColors[p3 + 1];
          colArr[j3 + 2] = masterColors[p3 + 2];
        }

        cloud.points.geometry.attributes.position.needsUpdate = true;
        cloud.points.geometry.attributes.color.needsUpdate = true;
      }

      if (starMesh) starMesh.visible = (targetShape === 'tree');
      if (starMesh) starMesh.rotation.y += 0.6 * dt;

      const sPos = snowSystem.geometry.attributes.position.array;
      for (let i = 0; i < CONFIG.snowCount; i++) {
        sPos[i * 3 + 1] -= snowVelocities[i] * dt * 6.0;
        if (sPos[i * 3 + 1] < -10) {
          sPos[i * 3 + 1] = 30;
          sPos[i * 3]     = (Math.random() - 0.5) * 60;
          sPos[i * 3 + 2] = (Math.random() - 0.5) * 60;
        }
      }
      snowSystem.geometry.attributes.position.needsUpdate = true;

      composer.render();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>
